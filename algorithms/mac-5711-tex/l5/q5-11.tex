\\[12pt]
\noindent 11. \textbf{(CLRS 8.4-2}: Qual é o consumo de tempo do pior caso para o $\proc{BucketSort}$? Que simples ajuste do algoritmo melhora o seu pior caso para $O(n \lg n)$ e mantem o seu consumo esperado de tempo linear.
\\[6pt]
\noindent \textbf{Resposta:} A resposta do exercício é baseada no algoritmo do livro do CLRS, conforme descrito abaixo:

\begin{codebox}
 \Procname{$\proc{BucketSort}(A)$}
 \li Let $B[0..n-1]$ be a new array
 \li $n \gets \attrib{A}{length}$
 \li \For $i \gets 0$ \To $n-1$
 \li    \Do
	  make $B[i]$ an empty list
	\End
 \li \For $i \gets 1$ \To $n$
 \li	\Do
	  insert $A[i]$ into list $B[\lfloor nA[i] \rfloor]$
	\End
 \li \For $i \gets 0$ \To $n-1$
 \li	\Do
	  sort list $B[i]$ with insertion sort
	\End
 \li concatenate the lists $B[0], B[1], \cdots, B[n-1]$ together in order
\end{codebox}

\noindent O pior caso do $\proc{BucketSort}$ acontence quando a entrada não segue uma distribuição uniforme e todos os itens caem em um único \textit{Bucket}. Como o algoritmo apresentado no CLRS utiliza \textit{insertion sort} para ordenar cada \textit{Bucket} ele gastará tempo $O(n^2)$ no pior caso. Podemos trocar o \textit{insertion sort} pelo $\proc{Mergesort}$ ou $\proc{Heapsort}$ que gastam $O(n \lg n)$ no pior caso. Na prática o \textit{insertion sort} é a melhor opção por que embora gaste tempo $O(n^2)$ \textit{insertion sort} é mais rápido que o $\proc{Mergesort}$ ou o $\proc{Heapsort}$ para vetores pequenos, note que para que o $\proc{BucketSort}$ seja uma boa opção cada \textit{Bucket} tem que ter um número pequeno de elementos.\\[12pt]
